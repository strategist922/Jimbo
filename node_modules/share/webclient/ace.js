// Generated by CoffeeScript 1.5.0
(function() {
  var Range, applyToShareJS, cursorToRange, rangeToCursor, requireImpl,
    __hasProp = {}.hasOwnProperty;

  requireImpl = ace.require != null ? ace.require : require;

  Range = requireImpl("ace/range").Range;

  rangeToCursor = function(editorDoc, range) {
    var end, i, line, lines, offset, start, _i, _len, _ref;
    lines = editorDoc.$lines;
    _ref = [null, null], start = _ref[0], end = _ref[1];
    offset = 0;
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      if (i === range.start.row && !start) {
        start = offset + range.start.column + range.start.row;
      }
      if (i === range.end.row && !end) {
        end = offset + range.end.column + range.end.row;
      }
      offset += line.length;
      if ((start != null) && (end != null)) {
        return [start, end];
      }
    }
    return [start, end];
  };

  cursorToRange = function(editorDoc, cursor) {
    var end, i, line, lines, offset, range, start, _i, _len, _ref;
    if (!(cursor instanceof Array)) {
      cursor = [cursor, cursor];
    }
    lines = editorDoc.$lines;
    offset = 0;
    _ref = [null, null], start = _ref[0], end = _ref[1];
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      if (offset + line.length >= cursor[0] && !start) {
        start = {
          row: i,
          column: cursor[0] - offset
        };
      }
      if (offset + line.length >= cursor[1] && !end) {
        end = {
          row: i,
          column: cursor[1] - offset
        };
      }
      if (start && end) {
        range = new Range();
        range.cursor = {
          row: end.row,
          column: end.column
        };
        range.start = start;
        range.end = end;
        return range;
      }
      offset += line.length + 1;
    }
  };

  applyToShareJS = function(editorDoc, delta, doc) {
    var pos, text;
    pos = rangeToCursor(editorDoc, delta.range)[0];
    switch (delta.action) {
      case 'insertText':
        doc.insert(pos, delta.text);
        break;
      case 'removeText':
        doc.del(pos, delta.text.length);
        break;
      case 'insertLines':
        text = delta.lines.join('\n') + '\n';
        doc.insert(pos, text);
        break;
      case 'removeLines':
        text = delta.lines.join('\n') + '\n';
        doc.del(pos, text.length);
        break;
      default:
        throw new Error("unknown action: " + delta.action);
    }
  };

  window.sharejs.extendDoc('attach_ace', function(editor, keepEditorContents) {
    var check, cursorListener, deleteListener, doc, docListener, editorDoc, editorListener, insertListener, offsetToPos, refreshListener, replaceTokenizer, suppress;
    if (!this.provides['text']) {
      throw new Error('Only text documents can be attached to ace');
    }
    doc = this;
    editorDoc = editor.getSession().getDocument();
    editorDoc.setNewLineMode('unix');
    check = function() {
      return window.setTimeout(function() {
        var editorText, otText;
        editorText = editorDoc.getValue();
        otText = doc.getText();
        if (editorText !== otText) {
          console.error("Text does not match!");
          console.error("editor: " + editorText);
          return console.error("ot:     " + otText);
        }
      }, 0);
    };
    if (keepEditorContents) {
      doc.del(0, doc.getText().length);
      doc.insert(0, editorDoc.getValue());
    } else {
      editorDoc.setValue(doc.getText());
    }
    check();
    suppress = false;
    doc.updateCursors = function() {
      var cursor, cursorElement, cursorLayer, i, indexToId, inserts, marker, myId, range, ranges, sessionId, user_id, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (!window.clients) {
        return;
      }
      if ((_ref = this.markers) == null) {
        this.markers = [];
      }
      _ref1 = this.markers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        marker = _ref1[_i];
        editor.session.removeMarker(marker);
      }
      ranges = [];
      myId = window.clients ? window.clients.indexOf(doc.connection.id) : void 0;
      inserts = 0;
      indexToId = {};
      _ref2 = this.cursors;
      for (sessionId in _ref2) {
        if (!__hasProp.call(_ref2, sessionId)) continue;
        cursor = _ref2[sessionId];
        user_id = window.clients.indexOf(sessionId);
        if (user_id === -1) {
          continue;
        }
        range = cursorToRange(editorDoc, cursor);
        if (!range) {
          continue;
        }
        this.markers.push = editor.session.addMarker(range, "foreign_selection ace_selection user_" + user_id, "line");
        ranges.push(range);
        indexToId[inserts] = user_id;
        inserts++;
      }
      ranges.push({
        cursor: null
      });
      indexToId[inserts] = myId;
      editor.session.$selectionMarkers = ranges;
      cursorLayer = editor.renderer.$cursorLayer;
      cursorLayer.update(editor.renderer.layerConfig);
      _ref3 = cursorLayer.cursors;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        cursorElement = _ref3[i];
        cursorElement.className = "ace_cursor user_" + indexToId[i];
      }
      return doc.cursor;
    };
    this.on("cursors", doc.updateCursors);
    editorListener = function(change) {
      if (suppress) {
        return;
      }
      applyToShareJS(editorDoc, change.data, doc);
      doc.updateCursors();
      return check();
    };
    replaceTokenizer = function() {
      var oldGetLineTokens, oldTokenizer;
      oldTokenizer = editor.getSession().getMode().getTokenizer();
      oldGetLineTokens = oldTokenizer.getLineTokens;
      return oldTokenizer.getLineTokens = function(line, state) {
        var cIter, docTokens, modeTokens;
        if ((state == null) || typeof state === "string") {
          cIter = doc.createIterator(0);
          state = {
            modeState: state
          };
        } else {
          cIter = doc.cloneIterator(state.iter);
          doc.consumeIterator(cIter, 1);
        }
        modeTokens = oldGetLineTokens.apply(oldTokenizer, [line, state.modeState]);
        docTokens = doc.consumeIterator(cIter, line.length);
        if (docTokens.text !== line) {
          return modeTokens;
        }
        return {
          tokens: doc.mergeTokens(docTokens, modeTokens.tokens),
          state: {
            modeState: modeTokens.state,
            iter: doc.cloneIterator(cIter)
          }
        };
      };
    };
    if (doc.getAttributes != null) {
      replaceTokenizer();
    }
    cursorListener = function(change) {
      var cursor;
      cursor = rangeToCursor(editorDoc, editor.getSelectionRange());
      return doc.setCursor(cursor);
    };
    editorDoc.on('change', editorListener);
    editor.on("changeSelection", cursorListener);
    docListener = function(op) {
      suppress = true;
      applyToDoc(editorDoc, op);
      suppress = false;
      return check();
    };
    offsetToPos = function(offset) {
      var line, lines, row, _i, _len;
      lines = editorDoc.getAllLines();
      row = 0;
      for (row = _i = 0, _len = lines.length; _i < _len; row = ++_i) {
        line = lines[row];
        if (offset <= line.length) {
          break;
        }
        offset -= lines[row].length + 1;
      }
      return {
        row: row,
        column: offset
      };
    };
    doc.on('insert', insertListener = function(pos, text) {
      suppress = true;
      editorDoc.insert(offsetToPos(pos), text);
      suppress = false;
      return check();
    });
    doc.on('delete', deleteListener = function(pos, text) {
      var range;
      suppress = true;
      range = Range.fromPoints(offsetToPos(pos), offsetToPos(pos + text.length));
      editorDoc.remove(range);
      suppress = false;
      return check();
    });
    doc.on('refresh', refreshListener = function(startoffset, length) {
      var range;
      range = Range.fromPoints(offsetToPos(startoffset), offsetToPos(startoffset + length));
      return editor.getSession().bgTokenizer.start(range.start.row);
    });
    doc.detach_ace = function() {
      doc.removeListener('insert', insertListener);
      doc.removeListener('delete', deleteListener);
      doc.removeListener('remoteop', docListener);
      doc.removeListener('refresh', refreshListener);
      doc.removeListener('cursors', doc.updateCursors);
      editorDoc.removeListener('change', editorListener);
      editor.removeListener('changeSelection', cursorListener);
      return delete doc.detach_ace;
    };
  });

}).call(this);
