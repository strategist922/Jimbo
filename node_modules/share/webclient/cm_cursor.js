(function () {
  var applyToShareJS;
  var preActionCodemirrorContent;
    
  rangeToCursor = function(editorDoc, range) {    
    var start, end, startOffset = 0, endOffset, iter = 0, lastLineBefore = range.to.line - 1;        
    
    start = editorDoc.getRange({line:0,ch:0},{line:lastLineBefore,ch:editorDoc.doc.getLine(lastLineBefore).length}).length + range.to.ch + 1;
    end = start + editorDoc.getRange(range.from, range.to).length;     
    
    return [start, end];
  };

  cursorToRange = function(editorDoc, cursor) {
    var range, offset = 0, iter = 0;
    if (!(cursor instanceof Array)) {
      cursor = [cursor, cursor];
    }
    
    var start = null, end = null;
    
    editorDoc.eachLine(funtion(line){
        if(offset + line.text.length >= cursor[0] && !start) {
            start = {from: iter, ch: cursor[0] - offset};
        }                
        if(offset + line.text.length >= cursor && !end) {
            end = {from: iter, ch: cursor[1] - offset};
        }
        if(start && end) {
            range = {from: start, to: end};
            return range;
        }
        offset += line.text.length + 1;
    });        
  };
  
  applyToShareJS = function (editorDoc, delta, doc) {
    var pos, text;
    change = delta;
    while (1) {
      pos = myIndexFromPos(change.from.line, change.from.ch, preActionCodemirrorContent);
      end_pos = myIndexFromPos(change.to.line, change.to.ch, preActionCodemirrorContent);
      action = '';
      if (change.text[0] == "" && change.text.length == 1) {
        if (change.from.line != change.to.line)
          action = 'removeLines';
        else
          action = 'removeText';
      }
      else {
        if (change.text.length > 1)
          action = 'insertLines';
        else
          action = 'insertText';
      }
      switch (action) {
      case 'insertText':
        if (pos != end_pos)
          doc.del(pos, end_pos - pos);
        doc.insert(pos, change.text[0]);
        break;
      case 'removeText':
        doc.del(pos, end_pos - pos);
        break;
      case 'insertLines':
        if (pos != end_pos)
          doc.del(pos, end_pos - pos);
        text = change.text.join('\n');
        doc.insert(pos, text);
        break;
      case 'removeLines':
        doc.del(pos, end_pos - pos);
        break;
      default:
        throw new Error("unknown action: " + action);
      }

      preActionCodemirrorContent = doc.getText();
      if (!change.next)
        break;
      change = change.next;
    }
  };

  window.sharejs.Doc.prototype.attach_cm = function (editor, keepEditorContents) {
    var check, cursorListener, doc, editorDoc, editorListener, suppress;
    if (!this.provides['text']) {
      throw new Error('Only text documents can be attached to CodeMirror');
    }
    doc = this;
    editorDoc = editor;

    check = function () {
      return window.setTimeout(function () {
        var editorText, otText;
        editorText = editorDoc.getValue();
        otText = doc.getText();
        if (editorText !== otText) {
          console.error("Texts are out of sync. Most likely this is caused by a bug in this code.");
        }
      }, 0);
    };
    if (keepEditorContents) {
      doc.del(0, doc.getText().length);
      doc.insert(0, editorDoc.getValue());
    } else {
      editorDoc.setValue(doc.getText());
    }
    preActionCodemirrorContent = editorDoc.getValue();
    check();
    suppress = false;
    
    doc.updateCursors = function() {
      var cursor, cursorElement, cursorLayer, i, indexToId, inserts, marker, myId, range, ranges, sessionId, user_id, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (!window.clients) {
        return;
      }
      if ((_ref = this.markers) == null) {
        this.markers = [];
      }
      _ref1 = this.markers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        marker = _ref1[_i];
        marker.clear()
      }
      ranges = [];
      myId = window.clients ? window.clients.indexOf(doc.connection.id) : void 0;
      inserts = 0;
      indexToId = {};
      _ref2 = this.cursors;
      for (sessionId in _ref2) {
        if (!__hasProp.call(_ref2, sessionId)) continue;
        cursor = _ref2[sessionId];
        user_id = window.clients.indexOf(sessionId);
        if (user_id === -1) {
          continue;
        }
        range = cursorToRange(editorDoc, cursor);
        if (!range) {
          continue;
        }
        this.markers.push = editorDoc.markText(range.from, range.to, {className:"foreign_selection cm_selection user_" + user_id});
        ranges.push(range);
        indexToId[inserts] = user_id;
        inserts++;
      }
      ranges.push({
        cursor: null
      });
      indexToId[inserts] = myId;
      // editor.session.$selectionMarkers = ranges;
      // cursorLayer = editor.renderer.$cursorLayer;
      // cursorLayer.update(editor.renderer.layerConfig);
      // _ref3 = cursorLayer.cursors;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        cursorElement = _ref3[i];
        cursorElement.className = "ace_cursor user_" + indexToId[i];
      }
      return doc.cursor;
    };
    
    this.on("cursors", doc.updateCursors);
    
    doc.onChange = function () {
    }

    editorListener = function (change, tc) {
      if (suppress) return;
      applyToShareJS(editorDoc, tc, doc);
      doc.onChange();
      return check();
    };
    editorDoc.on("change", editorListener);
    myIndexFromPos = function (line, ch, value) {
      myIndex = 0;
      count = 0;
      lines = value.split("\n");
      for (i = 0; i < lines.length; i++) {
        if (count < line)
          myIndex += lines[i].length + 1
        else {
          myIndex += ch;
          break;
        }
        count++;
      }
      return myIndex;
    }
    doc.on('insert', function (pos, text) {
      suppress = true;
      start = editorDoc.posFromIndex(pos);
      editorDoc.replaceRange(text, start);
      suppress = false;
      preActionCodemirrorContent = editorDoc.getValue();
      return check();
    });
    doc.on('delete', function (pos, text) {
      var range;
      suppress = true;
      start = editorDoc.posFromIndex(pos);
      end = editorDoc.posFromIndex(pos + text.length);
      editorDoc.replaceRange("", start, end);
      suppress = false;
      preActionCodemirrorContent = editorDoc.getValue();
      return check();
    });
    doc.detach_cm = function () {
      editorDoc.off('change', editorListener);
      return delete doc.detach_cm;
    };
  };

}).call(this);